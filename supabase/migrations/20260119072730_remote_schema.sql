create type "public"."color_source" as enum ('99COLORS_NET', 'ART_PAINTS_YG07S', 'BYRNE', 'CRAYOLA', 'CMYK_COLOR_MODEL', 'COLORCODE_IS', 'COLORHEXA', 'COLORXS', 'CORNELL_UNIVERSITY', 'COLUMBIA_UNIVERSITY', 'DUKE_UNIVERSITY', 'ENCYCOLORPEDIA_COM', 'ETON_COLLEGE', 'FANTETTI_AND_PETRACCHI', 'FINDTHEDATA_COM', 'FERRARIO_1919', 'FEDERAL_STANDARD_595', 'FLAG_OF_INDIA', 'FLAG_OF_SOUTH_AFRICA', 'GLAZEBROOK_AND_BALDRY', 'GOOGLE', 'HEXCOLOR_CO', 'ISCC_NBS', 'KELLY_MOORE', 'MATTEL', 'MAERZ_AND_PAUL', 'MILK_PAINT', 'MUNSELL_COLOR_WHEEL', 'NATURAL_COLOR_SYSTEM', 'PANTONE', 'PLOCHERE', 'POURPRE_COM', 'RAL', 'RESENE', 'RGB_COLOR_MODEL', 'THOM_POOLE', 'UNIVERSITY_OF_ALABAMA', 'UNIVERSITY_OF_CALIFORNIA_DAVIS', 'UNIVERSITY_OF_CAMBRIDGE', 'UNIVERSITY_OF_NORTH_CAROLINA', 'UNIVERSITY_OF_TEXAS_AT_AUSTIN', 'X11_WEB', 'XONA_COM');

create sequence "public"."documents_id_seq";

create sequence "public"."nods_page_id_seq";

create sequence "public"."nods_page_section_id_seq";

alter table "public"."binary_data" drop constraint "CHK_binary_data_sourceType";

alter table "public"."workflow_publish_history" drop constraint "CHK_workflow_publish_history_event";


  create table "public"."colors" (
    "id" bigint generated by default as identity not null,
    "name" text,
    "hex" text not null,
    "red" smallint,
    "green" smallint,
    "blue" smallint,
    "hue" smallint,
    "sat_hsl" smallint,
    "light_hsl" smallint,
    "sat_hsv" smallint,
    "val_hsv" smallint,
    "source" public.color_source
      );



  create table "public"."documents" (
    "id" bigint not null default nextval('public.documents_id_seq'::regclass),
    "content" text,
    "metadata" jsonb,
    "embedding" public.vector(1536)
      );



  create table "public"."nods_page" (
    "id" bigint not null default nextval('public.nods_page_id_seq'::regclass),
    "parent_page_id" bigint,
    "path" text not null,
    "checksum" text,
    "meta" jsonb,
    "type" text,
    "source" text
      );


alter table "public"."nods_page" enable row level security;


  create table "public"."nods_page_section" (
    "id" bigint not null default nextval('public.nods_page_section_id_seq'::regclass),
    "page_id" bigint not null,
    "content" text,
    "token_count" integer,
    "embedding" public.vector(1536),
    "slug" text,
    "heading" text
      );


alter table "public"."nods_page_section" enable row level security;


  create table "public"."todos" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "task" text,
    "is_complete" boolean default false,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."todos" enable row level security;

alter sequence "public"."documents_id_seq" owned by "public"."documents"."id";

alter sequence "public"."nods_page_id_seq" owned by "public"."nods_page"."id";

alter sequence "public"."nods_page_section_id_seq" owned by "public"."nods_page_section"."id";

CREATE UNIQUE INDEX colors_pkey ON public.colors USING btree (id);

CREATE UNIQUE INDEX documents_pkey ON public.documents USING btree (id);

CREATE UNIQUE INDEX nods_page_path_key ON public.nods_page USING btree (path);

CREATE UNIQUE INDEX nods_page_pkey ON public.nods_page USING btree (id);

CREATE UNIQUE INDEX nods_page_section_pkey ON public.nods_page_section USING btree (id);

CREATE UNIQUE INDEX todos_pkey ON public.todos USING btree (id);

alter table "public"."colors" add constraint "colors_pkey" PRIMARY KEY using index "colors_pkey";

alter table "public"."documents" add constraint "documents_pkey" PRIMARY KEY using index "documents_pkey";

alter table "public"."nods_page" add constraint "nods_page_pkey" PRIMARY KEY using index "nods_page_pkey";

alter table "public"."nods_page_section" add constraint "nods_page_section_pkey" PRIMARY KEY using index "nods_page_section_pkey";

alter table "public"."todos" add constraint "todos_pkey" PRIMARY KEY using index "todos_pkey";

alter table "public"."nods_page" add constraint "nods_page_parent_page_id_fkey" FOREIGN KEY (parent_page_id) REFERENCES public.nods_page(id) not valid;

alter table "public"."nods_page" validate constraint "nods_page_parent_page_id_fkey";

alter table "public"."nods_page" add constraint "nods_page_path_key" UNIQUE using index "nods_page_path_key";

alter table "public"."nods_page_section" add constraint "nods_page_section_page_id_fkey" FOREIGN KEY (page_id) REFERENCES public.nods_page(id) ON DELETE CASCADE not valid;

alter table "public"."nods_page_section" validate constraint "nods_page_section_page_id_fkey";

alter table "public"."todos" add constraint "todos_task_check" CHECK ((char_length(task) > 3)) not valid;

alter table "public"."todos" validate constraint "todos_task_check";

alter table "public"."todos" add constraint "todos_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."todos" validate constraint "todos_user_id_fkey";

alter table "public"."binary_data" add constraint "CHK_binary_data_sourceType" CHECK ((("sourceType")::text = ANY ((ARRAY['execution'::character varying, 'chat_message_attachment'::character varying])::text[]))) not valid;

alter table "public"."binary_data" validate constraint "CHK_binary_data_sourceType";

alter table "public"."workflow_publish_history" add constraint "CHK_workflow_publish_history_event" CHECK (((event)::text = ANY ((ARRAY['activated'::character varying, 'deactivated'::character varying])::text[]))) not valid;

alter table "public"."workflow_publish_history" validate constraint "CHK_workflow_publish_history_event";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_page_parents(page_id bigint)
 RETURNS TABLE(id bigint, parent_page_id bigint, path text, meta jsonb)
 LANGUAGE sql
AS $function$
  with recursive chain as (
    select *
    from nods_page
    where id = page_id

    union all

    select child.*
      from nods_page as child
      join chain on chain.parent_page_id = child.id
  )
  select id, parent_page_id, path, meta
  from chain;
$function$
;

CREATE OR REPLACE FUNCTION public.match_documents(query_embedding public.vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb)
 RETURNS TABLE(id bigint, content text, metadata jsonb, similarity double precision)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.content,
    d.metadata,
    1 - (d.embedding <=> query_embedding) AS similarity
  FROM documents d
  WHERE (filter = '{}' OR d.metadata @> filter)
  ORDER BY d.embedding <=> query_embedding
  LIMIT COALESCE(match_count, 50); -- default to 50 if match_count is NULL
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_page_sections(embedding public.vector, match_threshold double precision, match_count integer, min_content_length integer)
 RETURNS TABLE(id bigint, page_id bigint, slug text, heading text, content text, similarity double precision)
 LANGUAGE plpgsql
AS $function$
#variable_conflict use_variable
begin
  return query
  select
    nods_page_section.id,
    nods_page_section.page_id,
    nods_page_section.slug,
    nods_page_section.heading,
    nods_page_section.content,
    (nods_page_section.embedding <#> embedding) * -1 as similarity
  from nods_page_section

  -- We only care about sections that have a useful amount of content
  where length(nods_page_section.content) >= min_content_length

  -- The dot product is negative because of a Postgres limitation, so we negate it
  and (nods_page_section.embedding <#> embedding) * -1 > match_threshold

  -- OpenAI embeddings are normalized to length 1, so
  -- cosine similarity and dot product will produce the same results.
  -- Using dot product which can be computed slightly faster.
  --
  -- For the different syntaxes, see https://github.com/pgvector/pgvector
  order by nods_page_section.embedding <#> embedding

  limit match_count;
end;
$function$
;

grant delete on table "public"."colors" to "anon";

grant insert on table "public"."colors" to "anon";

grant references on table "public"."colors" to "anon";

grant select on table "public"."colors" to "anon";

grant trigger on table "public"."colors" to "anon";

grant truncate on table "public"."colors" to "anon";

grant update on table "public"."colors" to "anon";

grant delete on table "public"."colors" to "authenticated";

grant insert on table "public"."colors" to "authenticated";

grant references on table "public"."colors" to "authenticated";

grant select on table "public"."colors" to "authenticated";

grant trigger on table "public"."colors" to "authenticated";

grant truncate on table "public"."colors" to "authenticated";

grant update on table "public"."colors" to "authenticated";

grant delete on table "public"."colors" to "service_role";

grant insert on table "public"."colors" to "service_role";

grant references on table "public"."colors" to "service_role";

grant select on table "public"."colors" to "service_role";

grant trigger on table "public"."colors" to "service_role";

grant truncate on table "public"."colors" to "service_role";

grant update on table "public"."colors" to "service_role";

grant delete on table "public"."documents" to "anon";

grant insert on table "public"."documents" to "anon";

grant references on table "public"."documents" to "anon";

grant select on table "public"."documents" to "anon";

grant trigger on table "public"."documents" to "anon";

grant truncate on table "public"."documents" to "anon";

grant update on table "public"."documents" to "anon";

grant delete on table "public"."documents" to "authenticated";

grant insert on table "public"."documents" to "authenticated";

grant references on table "public"."documents" to "authenticated";

grant select on table "public"."documents" to "authenticated";

grant trigger on table "public"."documents" to "authenticated";

grant truncate on table "public"."documents" to "authenticated";

grant update on table "public"."documents" to "authenticated";

grant delete on table "public"."documents" to "service_role";

grant insert on table "public"."documents" to "service_role";

grant references on table "public"."documents" to "service_role";

grant select on table "public"."documents" to "service_role";

grant trigger on table "public"."documents" to "service_role";

grant truncate on table "public"."documents" to "service_role";

grant update on table "public"."documents" to "service_role";

grant delete on table "public"."nods_page" to "anon";

grant insert on table "public"."nods_page" to "anon";

grant references on table "public"."nods_page" to "anon";

grant select on table "public"."nods_page" to "anon";

grant trigger on table "public"."nods_page" to "anon";

grant truncate on table "public"."nods_page" to "anon";

grant update on table "public"."nods_page" to "anon";

grant delete on table "public"."nods_page" to "authenticated";

grant insert on table "public"."nods_page" to "authenticated";

grant references on table "public"."nods_page" to "authenticated";

grant select on table "public"."nods_page" to "authenticated";

grant trigger on table "public"."nods_page" to "authenticated";

grant truncate on table "public"."nods_page" to "authenticated";

grant update on table "public"."nods_page" to "authenticated";

grant delete on table "public"."nods_page" to "service_role";

grant insert on table "public"."nods_page" to "service_role";

grant references on table "public"."nods_page" to "service_role";

grant select on table "public"."nods_page" to "service_role";

grant trigger on table "public"."nods_page" to "service_role";

grant truncate on table "public"."nods_page" to "service_role";

grant update on table "public"."nods_page" to "service_role";

grant delete on table "public"."nods_page_section" to "anon";

grant insert on table "public"."nods_page_section" to "anon";

grant references on table "public"."nods_page_section" to "anon";

grant select on table "public"."nods_page_section" to "anon";

grant trigger on table "public"."nods_page_section" to "anon";

grant truncate on table "public"."nods_page_section" to "anon";

grant update on table "public"."nods_page_section" to "anon";

grant delete on table "public"."nods_page_section" to "authenticated";

grant insert on table "public"."nods_page_section" to "authenticated";

grant references on table "public"."nods_page_section" to "authenticated";

grant select on table "public"."nods_page_section" to "authenticated";

grant trigger on table "public"."nods_page_section" to "authenticated";

grant truncate on table "public"."nods_page_section" to "authenticated";

grant update on table "public"."nods_page_section" to "authenticated";

grant delete on table "public"."nods_page_section" to "service_role";

grant insert on table "public"."nods_page_section" to "service_role";

grant references on table "public"."nods_page_section" to "service_role";

grant select on table "public"."nods_page_section" to "service_role";

grant trigger on table "public"."nods_page_section" to "service_role";

grant truncate on table "public"."nods_page_section" to "service_role";

grant update on table "public"."nods_page_section" to "service_role";

grant delete on table "public"."todos" to "anon";

grant insert on table "public"."todos" to "anon";

grant references on table "public"."todos" to "anon";

grant select on table "public"."todos" to "anon";

grant trigger on table "public"."todos" to "anon";

grant truncate on table "public"."todos" to "anon";

grant update on table "public"."todos" to "anon";

grant delete on table "public"."todos" to "authenticated";

grant insert on table "public"."todos" to "authenticated";

grant references on table "public"."todos" to "authenticated";

grant select on table "public"."todos" to "authenticated";

grant trigger on table "public"."todos" to "authenticated";

grant truncate on table "public"."todos" to "authenticated";

grant update on table "public"."todos" to "authenticated";

grant delete on table "public"."todos" to "service_role";

grant insert on table "public"."todos" to "service_role";

grant references on table "public"."todos" to "service_role";

grant select on table "public"."todos" to "service_role";

grant trigger on table "public"."todos" to "service_role";

grant truncate on table "public"."todos" to "service_role";

grant update on table "public"."todos" to "service_role";


  create policy "Individuals can create todos."
  on "public"."todos"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Individuals can delete their own todos."
  on "public"."todos"
  as permissive
  for delete
  to public
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Individuals can update their own todos."
  on "public"."todos"
  as permissive
  for update
  to public
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Individuals can view their own todos. "
  on "public"."todos"
  as permissive
  for select
  to public
using ((( SELECT auth.uid() AS uid) = user_id));


-- Storage triggers: only create if storage schema exists (for local dev compatibility)
-- Storage is disabled locally (enabled = false in config.toml), so these may not exist
DO $$
BEGIN
  -- Check if storage.buckets exists before creating trigger
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'storage' AND table_name = 'buckets') THEN
    DROP TRIGGER IF EXISTS enforce_bucket_name_length_trigger ON storage.buckets;
    CREATE TRIGGER enforce_bucket_name_length_trigger BEFORE INSERT OR UPDATE OF name ON storage.buckets FOR EACH ROW EXECUTE FUNCTION storage.enforce_bucket_name_length();
  END IF;

  -- Check if storage.objects exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'storage' AND table_name = 'objects') THEN
    DROP TRIGGER IF EXISTS objects_delete_delete_prefix ON storage.objects;
    CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();

    DROP TRIGGER IF EXISTS objects_insert_create_prefix ON storage.objects;
    CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();

    DROP TRIGGER IF EXISTS objects_update_create_prefix ON storage.objects;
    CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();

    DROP TRIGGER IF EXISTS update_objects_updated_at ON storage.objects;
    CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();
  END IF;

  -- Check if storage.prefixes exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'storage' AND table_name = 'prefixes') THEN
    DROP TRIGGER IF EXISTS prefixes_create_hierarchy ON storage.prefixes;
    CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();

    DROP TRIGGER IF EXISTS prefixes_delete_hierarchy ON storage.prefixes;
    CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();
  END IF;
END $$;


